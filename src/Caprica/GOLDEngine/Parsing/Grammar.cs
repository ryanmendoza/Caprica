using System;
using Caprica.Extensions;

namespace Caprica.GOLDEngine.Parsing
{
    /// <summary>
    ///     Grammars provide rules that specify the structure of languages, independently from the actual meaning of the content. Grammars
    ///     are classified according to the complexity of the structure they describe. The class of context free grammars (CFG) is the most
    ///     common one use to describe the syntax of programming languages. In this class, the category a token belongs to (e.g. reserved
    ///     words, identifiers, etc.) is what matters rather than the specific token (e.g. the identifier xyz).
    ///     In addition, the formatting of the program (the content of whitespace) and the actual text of identifiers does not affect the
    ///     syntax of the grammar. This is very important in parsing technology. Grammars that are not context free cannot be parsed by
    ///     the LR, LALR or LL parsing algorithms.
    /// </summary>
    public class Grammar
    {
        private const int PropertyCount = 8;

        private readonly string[] properties =
        {
            "", "", "", "", "", "", "", ""
        };

        /// <summary>
        ///     Gets a short description of the grammar.
        /// </summary>
        /// <value>
        ///     A short description of the grammar.
        /// </value>
        public string About => GetProperty(PropertyIndex.About);

        /// <summary>
        ///     Gets the grammar's author.
        /// </summary>
        /// <value>
        ///     The grammar's author.
        /// </value>
        public string Author => GetProperty(PropertyIndex.Author);

        /// <summary>
        ///     Gets the grammar's character mapping. For now, the only valid values are Windows-1252 and None. The
        ///     system defaults to Windows-1252 - which populates characters 128 to 159 as needed.
        /// </summary>
        /// <value>
        ///     The grammar's character mapping.
        /// </value>
        public string CharacterMapping => GetProperty(PropertyIndex.CharacterMapping);

        /// <summary>
        ///     Gets the grammar's character set.
        /// </summary>
        /// <value>
        ///     The grammar's character set.
        /// </value>
        public string CharacterSet => GetProperty(PropertyIndex.CharacterSet);

        /// <summary>
        ///     Gets the generated by.
        /// </summary>
        /// <value>
        ///     The generated by.
        /// </value>
        public string GeneratedBy => GetProperty(PropertyIndex.GeneratedBy);

        /// <summary>
        ///     Gets the generated date.
        /// </summary>
        /// <value>
        ///     The generated date.
        /// </value>
        public string GeneratedDate => GetProperty(PropertyIndex.GeneratedDate);

        /// <summary>
        ///     Gets the name of the grammar.
        /// </summary>
        /// <value>
        ///     The name of the grammar.
        /// </value>
        public string Name => GetProperty(PropertyIndex.Name);

        /// <summary>
        ///     Gets the version of the grammar. This can contain any alphanumeric string.
        /// </summary>
        /// <value>
        ///     The version of the grammar.
        /// </value>
        public string Version => GetProperty(PropertyIndex.Version);

        internal void Clear()
        {
            for (var i = 0; i < PropertyCount; i++)
            {
                properties[i] = string.Empty;
            }
        }

        internal string GetProperty(PropertyIndex propertyIndex)
        {
            var index = (int) propertyIndex;

            if (index.IsWithinRange(0, PropertyCount))
            {
                return properties[index];
            }

            throw new ArgumentOutOfRangeException(nameof(propertyIndex));
        }

        internal void SetProperty(int index, string value)
        {
            if (!index.IsWithinRange(0, PropertyCount)) throw new ArgumentOutOfRangeException(nameof(index));
            properties[index] = value;
        }

        #region Nested type: PropertyIndex

        internal enum PropertyIndex
        {
            About = 3,

            Author = 2,

            CharacterMapping = 5,

            CharacterSet = 4,

            GeneratedBy = 6,

            GeneratedDate = 7,

            Name = 0,

            Version = 1
        }

        #endregion
    }
}